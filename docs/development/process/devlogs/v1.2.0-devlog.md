# DevLog: v1.2.0 - Plugin System

## Implementation Narrative

v1.2.0 introduces a unified plugin architecture for extending Persona with custom formatters, loaders, providers, and validators. The system uses Python entry points for automatic discovery of third-party plugins.

### Phase 1: Core Infrastructure

The plugin system was designed around a generic registry pattern:

```
core/plugins/
├── __init__.py           # Public API
├── base.py               # PluginInfo, PluginRegistry[T], PluginType
├── discovery.py          # Entry point discovery
├── exceptions.py         # PluginError, PluginNotFoundError, etc.
├── manager.py            # PluginManager orchestrator
└── registries.py         # Concrete registry implementations
```

The `PluginRegistry[T]` generic base class enables type-safe registries for any plugin type, while sharing common functionality like registration, lookup, and enabling/disabling.

### Phase 2: Plugin Types and Entry Points

Five plugin types were defined with corresponding entry point groups:

| Type | Entry Point Group |
|------|-------------------|
| FORMATTER | `persona.formatters` |
| LOADER | `persona.loaders` |
| PROVIDER | `persona.providers` |
| VALIDATOR | `persona.validators` |
| WORKFLOW | `persona.workflows` |

Entry points are configured in `pyproject.toml`:

```toml
[project.entry-points."persona.formatters"]
# html = "my_package:HTMLFormatter"
```

### Phase 3: PluginRegistry Base Class

The base class provides a complete plugin lifecycle:

```python
class PluginRegistry(ABC, Generic[T]):
    plugin_type: PluginType
    entry_point_group: str

    def register(self, name, plugin_class, **metadata) -> None: ...
    def unregister(self, name) -> None: ...
    def get(self, name, **kwargs) -> T: ...
    def get_cached(self, name) -> T: ...
    def get_info(self, name) -> PluginInfo: ...
    def list_names(self) -> list[str]: ...
    def enable(self, name) -> None: ...
    def disable(self, name) -> None: ...
    def discover_entry_points(self) -> int: ...
```

Key design decisions:
- **Generic type parameter**: `PluginRegistry[T]` ensures type-safe plugin retrieval
- **Cached instances**: `get_cached()` returns the same instance for repeated calls
- **Entry point precedence**: Built-in plugins cannot be overridden by entry points
- **Enable/disable**: Plugins can be disabled without unregistering

### Phase 4: Entry Point Discovery

The discovery module uses `importlib.metadata` for Python 3.10+ compatible entry point loading:

```python
def discover_plugins(group: str, registry: PluginRegistry) -> int:
    eps = entry_points(group=group)
    for ep in eps:
        plugin_class = ep.load()
        registry.register_entry_point(
            name=ep.name,
            plugin_class=plugin_class,
            entry_point=f"{group}:{ep.name}",
        )
```

Plugin classes can expose metadata via special attributes:
- `__plugin_description__`
- `__plugin_version__`
- `__plugin_author__`

### Phase 5: Concrete Registries

Four registries were implemented, each registering built-in plugins:

**FormatterPluginRegistry**: json, markdown, text formatters
**LoaderPluginRegistry**: csv, json, yaml, markdown, text, html, org loaders
**ProviderPluginRegistry**: openai, anthropic, gemini providers
**ValidatorPluginRegistry**: persona validator

Total: 14 built-in plugins across 4 types.

### Phase 6: PluginManager Orchestrator

The PluginManager provides unified access to all registries:

```python
manager = get_plugin_manager()

# List all plugins
plugins = manager.list_plugins()

# Filter by type
formatters = manager.list_plugins(plugin_type=PluginType.FORMATTER)

# Get plugin instance
formatter = manager.get_plugin(PluginType.FORMATTER, "json")

# Get summary
summary = manager.get_summary()
```

The global manager automatically initialises registries and discovers entry points on first access.

### Phase 7: CLI Commands

The `persona plugin` command group provides management capabilities:

```bash
persona plugin list              # List all plugins
persona plugin list --type loader  # Filter by type
persona plugin info json -t formatter  # Plugin details
persona plugin summary          # Overview statistics
persona plugin check            # Verify all plugins load
persona plugin reload           # Reload registries
```

Output formats include Rich tables, JSON, and panels for detailed info.

### Phase 8: Testing

Wrote 33 unit tests across 3 test files:

```
tests/unit/core/plugins/
├── test_base.py         # 21 tests for PluginInfo, PluginRegistry
├── test_manager.py      # 13 tests for PluginManager
└── test_exceptions.py   # 9 tests for exception classes
```

All tests pass with full suite at 2495 tests.

## Challenges Encountered

- **Test class naming**: A test helper class named `TestPluginRegistry` was collected by pytest as a test class. Renamed to `MockPluginRegistry` to avoid confusion.

- **Generic type hints**: The `PluginRegistry[T]` generic required careful handling of TypeVar and Generic imports for proper type checking.

- **Global state in tests**: The global plugin manager singleton required consideration for test isolation.

## Code Highlights

### Generic Registry Base

```python
T = TypeVar("T")

class PluginRegistry(ABC, Generic[T]):
    def get(self, name: str, **kwargs: Any) -> T:
        if name not in self._plugins:
            raise KeyError(f"Plugin '{name}' not found")
        info = self._plugins[name]
        return info.plugin_class(**kwargs)
```

### Entry Point Discovery

```python
def discover_plugins(group: str, registry: PluginRegistry) -> int:
    from importlib.metadata import entry_points
    eps = entry_points(group=group)
    count = 0
    for ep in eps:
        try:
            plugin_class = ep.load()
            registry.register_entry_point(name=ep.name, ...)
            count += 1
        except Exception as e:
            warnings.warn(f"Failed to load plugin '{ep.name}': {e}")
    return count
```

### Plugin Summary

```python
def get_summary(self) -> dict[str, Any]:
    summary = {
        "total": 0,
        "enabled": 0,
        "builtin": 0,
        "external": 0,
        "by_type": {},
    }
    for plugin_type, registry in self._registries.items():
        type_summary = {
            "total": len(registry.list_names()),
            "enabled": len(registry.list_enabled()),
            "builtin": len(registry.list_builtin()),
            "external": len(registry.list_external()),
        }
        summary["by_type"][plugin_type.value] = type_summary
        # Aggregate totals...
    return summary
```

## Dependencies Added

No new dependencies required. All features implemented using:
- `dataclasses` - PluginInfo dataclass
- `enum` - PluginType enum
- `typing` - Generic, TypeVar
- `importlib.metadata` - Entry point discovery
- `rich` - CLI output formatting (already a project dependency)

## Summary

v1.2.0 provides a comprehensive plugin architecture that enables third-party extensions without forking the codebase. The entry point system follows Python packaging standards, making it easy for external packages to register plugins.

Key benefits:
- **Type-safe**: Generic registries ensure correct plugin types
- **Discoverable**: Entry points are automatically loaded
- **Manageable**: CLI commands for listing, checking, and reloading
- **Backward compatible**: Existing API unchanged

With 33 dedicated tests and integration with the CLI, the plugin system is ready for production use.

---

## Related Documentation

- [F-107 Feature Spec](../../roadmap/features/completed/F-107-plugin-system.md)
- [v1.2.0 Retrospective](../retrospectives/v1.2.0-retrospective.md)
- [Manual Test Script](../../../../tests/manual/plugin_system_test_script.md)

---

**Status**: Completed

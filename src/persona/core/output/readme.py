"""
Automatic README generation for output folders.

This module generates README.md files for persona generation outputs,
providing context about what was generated and how to use the results.
"""

from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Any

from jinja2 import BaseLoader, Environment

from persona.core.generation.parser import Persona


@dataclass
class GenerationSummary:
    """Summary of a persona generation run."""

    generated_at: datetime
    experiment_name: str | None = None
    persona_count: int = 0
    provider: str | None = None
    model: str | None = None
    source_files: list[str] = field(default_factory=list)
    input_tokens: int = 0
    output_tokens: int = 0
    cost: float = 0.0


@dataclass
class PersonaSummary:
    """Brief summary of a generated persona."""

    name: str
    id: str
    title: str = ""
    goal_count: int = 0
    pain_point_count: int = 0


DEFAULT_README_TEMPLATE = """# Persona Generation Output

Generated: {{ summary.generated_at.strftime('%Y-%m-%d %H:%M:%S') }}
{% if summary.experiment_name %}Experiment: {{ summary.experiment_name }}{% endif %}

## Summary

- **Personas Generated**: {{ summary.persona_count }}
{% if summary.provider %}- **Provider**: {{ summary.provider }}{% if summary.model %} ({{ summary.model }}){% endif %}{% endif %}
{% if summary.source_files %}- **Source Files**: {{ summary.source_files|length }} ({{ summary.source_files[:3]|join(', ') }}{% if summary.source_files|length > 3 %}, ...{% endif %}){% endif %}
{% if summary.cost > 0 %}- **Estimated Cost**: ${{ "%.2f"|format(summary.cost) }}{% endif %}
{% if summary.input_tokens > 0 or summary.output_tokens > 0 %}
- **Tokens Used**: {{ summary.input_tokens + summary.output_tokens }} ({{ summary.input_tokens }} input, {{ summary.output_tokens }} output)
{% endif %}

## Personas

{% for persona in personas %}
{{ loop.index }}. **{{ persona.name }}**{% if persona.title %} - {{ persona.title }}{% endif %}

{% endfor %}

## Files

```
{{ output_dir }}/
├── README.md           # This file
├── metadata.json       # Generation metadata
{% if has_prompt %}├── prompt.txt          # The rendered prompt
{% endif %}{% if has_response %}├── full_response.txt   # Complete LLM response
{% endif %}{% if has_reasoning %}├── reasoning.txt       # LLM reasoning traces
{% endif %}└── personas/
{% for persona in personas %}    {% if loop.last %}└── {% else %}├── {% endif %}{{ "%02d"|format(loop.index) }}/
        ├── persona.json
        ├── persona.md
        └── persona.txt
{% endfor %}```

## Usage

### Loading Personas

```python
import json
from pathlib import Path

# Load a single persona
with open("personas/01/persona.json") as f:
    persona = json.load(f)

print(f"Name: {persona['name']}")
print(f"Goals: {persona['goals']}")
```

### Regenerating

To regenerate these personas with the same parameters:

```bash
persona generate --experiment {{ summary.experiment_name or 'my-experiment' }}
```

---

*Generated by [Persona](https://github.com/REPPL/Persona)*
"""


class ReadmeGenerator:
    """
    Generate README.md files for output folders.

    Creates human-readable documentation for generation results,
    including summaries, file listings, and usage instructions.

    Example:
        generator = ReadmeGenerator()
        readme = generator.generate(summary, personas)
        Path("outputs/README.md").write_text(readme)
    """

    def __init__(
        self,
        template: str | None = None,
    ) -> None:
        """
        Initialise README generator.

        Args:
            template: Optional custom Jinja2 template.
        """
        self._template_str = template or DEFAULT_README_TEMPLATE
        self._env = Environment(loader=BaseLoader())

    def generate(
        self,
        summary: GenerationSummary,
        personas: list[Persona],
        output_dir: str = ".",
        has_prompt: bool = True,
        has_response: bool = True,
        has_reasoning: bool = False,
    ) -> str:
        """
        Generate README content.

        Args:
            summary: Generation summary data.
            personas: List of generated personas.
            output_dir: Name of output directory.
            has_prompt: Whether prompt.txt exists.
            has_response: Whether full_response.txt exists.
            has_reasoning: Whether reasoning.txt exists.

        Returns:
            Generated README content as string.
        """
        template = self._env.from_string(self._template_str)

        persona_summaries = [
            PersonaSummary(
                name=p.name,
                id=p.id,
                title=self._extract_title(p),
                goal_count=len(p.goals) if p.goals else 0,
                pain_point_count=len(p.pain_points) if p.pain_points else 0,
            )
            for p in personas
        ]

        return template.render(
            summary=summary,
            personas=persona_summaries,
            output_dir=output_dir,
            has_prompt=has_prompt,
            has_response=has_response,
            has_reasoning=has_reasoning,
        )

    def generate_from_metadata(
        self,
        metadata: dict[str, Any],
        personas: list[Persona],
        output_dir: str = ".",
    ) -> str:
        """
        Generate README from metadata dictionary.

        Args:
            metadata: Metadata dictionary from metadata.json.
            personas: List of generated personas.
            output_dir: Name of output directory.

        Returns:
            Generated README content.
        """
        # Parse datetime
        generated_at = datetime.fromisoformat(
            metadata.get("generated_at", datetime.now().isoformat())
        )

        summary = GenerationSummary(
            generated_at=generated_at,
            experiment_name=metadata.get("experiment_name"),
            persona_count=metadata.get("persona_count", len(personas)),
            provider=metadata.get("provider"),
            model=metadata.get("model"),
            source_files=metadata.get("source_files", []),
            input_tokens=metadata.get("input_tokens", 0),
            output_tokens=metadata.get("output_tokens", 0),
            cost=metadata.get("cost", 0.0),
        )

        return self.generate(
            summary=summary,
            personas=personas,
            output_dir=output_dir,
            has_prompt=True,
            has_response=True,
            has_reasoning=metadata.get("has_reasoning", False),
        )

    def _extract_title(self, persona: Persona) -> str:
        """Extract or generate a title for the persona."""
        # Check additional fields for title
        if persona.additional:
            title = persona.additional.get("title", "")
            if title:
                return title

        # Try to derive from demographics
        if persona.demographics:
            role = persona.demographics.get("role", "")
            if role:
                return f"The {role}"

        return ""

    def save(
        self,
        output_dir: Path,
        summary: GenerationSummary,
        personas: list[Persona],
    ) -> Path:
        """
        Save README to output directory.

        Args:
            output_dir: Path to output directory.
            summary: Generation summary.
            personas: List of generated personas.

        Returns:
            Path to saved README file.
        """
        readme_path = output_dir / "README.md"
        content = self.generate(
            summary=summary,
            personas=personas,
            output_dir=output_dir.name,
            has_prompt=(output_dir / "prompt.txt").exists(),
            has_response=(output_dir / "full_response.txt").exists(),
            has_reasoning=(output_dir / "reasoning.txt").exists(),
        )
        readme_path.write_text(content, encoding="utf-8")
        return readme_path


class CustomReadmeTemplate:
    """
    Helper for creating custom README templates.

    Provides template variables and validation for custom templates.
    """

    AVAILABLE_VARIABLES = {
        "summary": "GenerationSummary object with generation metadata",
        "summary.generated_at": "datetime when generation occurred",
        "summary.experiment_name": "Name of the experiment (optional)",
        "summary.persona_count": "Number of personas generated",
        "summary.provider": "LLM provider name (optional)",
        "summary.model": "Model ID used (optional)",
        "summary.source_files": "List of source file paths",
        "summary.input_tokens": "Input token count",
        "summary.output_tokens": "Output token count",
        "summary.cost": "Estimated cost in USD",
        "personas": "List of PersonaSummary objects",
        "personas[].name": "Persona name",
        "personas[].id": "Persona ID",
        "personas[].title": "Persona title/descriptor",
        "personas[].goal_count": "Number of goals",
        "personas[].pain_point_count": "Number of pain points",
        "output_dir": "Name of output directory",
        "has_prompt": "Boolean: prompt.txt exists",
        "has_response": "Boolean: full_response.txt exists",
        "has_reasoning": "Boolean: reasoning.txt exists",
    }

    @classmethod
    def get_example_template(cls) -> str:
        """Get the default template as an example."""
        return DEFAULT_README_TEMPLATE

    @classmethod
    def validate_template(cls, template: str) -> list[str]:
        """
        Validate a custom template.

        Args:
            template: Jinja2 template string.

        Returns:
            List of validation errors (empty if valid).
        """
        errors = []
        env = Environment(loader=BaseLoader())

        try:
            env.from_string(template)
        except Exception as e:
            errors.append(f"Template syntax error: {e}")

        return errors
